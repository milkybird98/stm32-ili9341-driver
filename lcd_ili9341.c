#include "lcd_ili9341.h"

uint8_t font[128][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0000 (nul)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0001
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0002
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0003
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0004
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0005
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0006
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0007
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0008
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0009
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+000A
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+000B
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+000C
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+000D
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+000E
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+000F
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0010
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0011
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0012
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0013
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0014
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0015
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0016
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0017
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0018
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0019
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+001A
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+001B
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+001C
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+001D
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+001E
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+001F
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0020 (space)
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},  // U+0021 (!)
    {0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0022 (")
    {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},  // U+0023 (#)
    {0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},  // U+0024 ($)
    {0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},  // U+0025 (%)
    {0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},  // U+0026 (&)
    {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0027 (')
    {0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},  // U+0028 (()
    {0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},  // U+0029 ())
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},  // U+002A (*)
    {0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},  // U+002B (+)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},  // U+002C (,)
    {0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},  // U+002D (-)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},  // U+002E (.)
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},  // U+002F (/)
    {0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},  // U+0030 (0)
    {0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},  // U+0031 (1)
    {0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},  // U+0032 (2)
    {0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},  // U+0033 (3)
    {0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},  // U+0034 (4)
    {0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},  // U+0035 (5)
    {0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},  // U+0036 (6)
    {0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},  // U+0037 (7)
    {0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},  // U+0038 (8)
    {0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},  // U+0039 (9)
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},  // U+003A (:)
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},  // U+003B (//)
    {0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},  // U+003C (<)
    {0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},  // U+003D (=)
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},  // U+003E (>)
    {0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},  // U+003F (?)
    {0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},  // U+0040 (@)
    {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},  // U+0041 (A)
    {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},  // U+0042 (B)
    {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},  // U+0043 (C)
    {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},  // U+0044 (D)
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},  // U+0045 (E)
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},  // U+0046 (F)
    {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},  // U+0047 (G)
    {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},  // U+0048 (H)
    {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},  // U+0049 (I)
    {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},  // U+004A (J)
    {0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},  // U+004B (K)
    {0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},  // U+004C (L)
    {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},  // U+004D (M)
    {0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},  // U+004E (N)
    {0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},  // U+004F (O)
    {0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},  // U+0050 (P)
    {0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},  // U+0051 (Q)
    {0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},  // U+0052 (R)
    {0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},  // U+0053 (S)
    {0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},  // U+0054 (T)
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},  // U+0055 (U)
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},  // U+0056 (V)
    {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},  // U+0057 (W)
    {0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},  // U+0058 (X)
    {0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},  // U+0059 (Y)
    {0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},  // U+005A (Z)
    {0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},  // U+005B ([)
    {0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},  // U+005C (\)
    {0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},  // U+005D (])
    {0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},  // U+005E (^)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},  // U+005F (_)
    {0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+0060 (`)
    {0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},  // U+0061 (a)
    {0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},  // U+0062 (b)
    {0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},  // U+0063 (c)
    {0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},  // U+0064 (d)
    {0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},  // U+0065 (e)
    {0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},  // U+0066 (f)
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},  // U+0067 (g)
    {0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},  // U+0068 (h)
    {0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},  // U+0069 (i)
    {0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},  // U+006A (j)
    {0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},  // U+006B (k)
    {0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},  // U+006C (l)
    {0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},  // U+006D (m)
    {0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},  // U+006E (n)
    {0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},  // U+006F (o)
    {0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},  // U+0070 (p)
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},  // U+0071 (q)
    {0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},  // U+0072 (r)
    {0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},  // U+0073 (s)
    {0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},  // U+0074 (t)
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},  // U+0075 (u)
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},  // U+0076 (v)
    {0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},  // U+0077 (w)
    {0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},  // U+0078 (x)
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},  // U+0079 (y)
    {0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},  // U+007A (z)
    {0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},  // U+007B ({)
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},  // U+007C (|)
    {0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},  // U+007D (})
    {0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // U+007E (~)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}   // U+007F
};

void drawEnSentence(uint16_t x, uint16_t y, char *character, uint8_t length,
                    uint16_t color) {
  for (int j = 0; j < length; j++) {
    drawEnWord(x + 9 * j, y, *(character + j), color);
  }
}

void drawEnWord(uint16_t x, uint16_t y, char character, uint16_t color) {
  for (int i = 0; i < 8; i++) {
    uint8_t nowlayerdots = font[character][i];
    for (int n = 0; n < 8; n++) {
      if ((nowlayerdots >> n) & 0x01) {
        drawPoint(x + n, y + i, color);
      }
    }
  }
}

void drawCnSentence(uint16_t x, uint16_t y, char *character, uint8_t length,
                    uint16_t color, uint16_t backcolor) {
  FRESULT res;
  FIL file_obj;
  res = f_open(&file_obj, "0:/hzk16h", FA_OPEN_EXISTING | FA_READ);
  if (res != FR_OK) {
    return;
  }

  for (int j = 0; j < length; j += 2) {
    if (*(character + j) <= 0x7f) {
      drawEnWord(x + 9 * j, y + 4, *(character + j), color);
      j--;
    } else {
      drawCnWord(x + 9 * j, y, (character + j), color,backcolor, file_obj);
    }
  }
}

void drawCnWord(uint16_t x, uint16_t y, char *character, uint16_t color, uint16_t backcolor,
                FIL file_obj) {
  uint16_t buffer[16];
	uint16_t charpic[16*16];
  uint32_t br;
  FRESULT res;

  int offset = (94 * (unsigned int)(*character - 0xa0 - 1) +
                (*(character + 1) - 0xa0 - 1)) *
               32;

  res = f_lseek(&file_obj, offset);
  if (res != FR_OK) {
		f_close(&file_obj);
    return;
  }

  res = f_read(&file_obj, buffer, 32, &br);
  if (res != FR_OK) {
		f_close(&file_obj);
    return;
  }

  for (int i = 0; i < 16; i++) {
    uint8_t temp = 0;

    temp = buffer[i] >> 8;

    buffer[i] = (buffer[i] & 0xff) << 8 | temp;
  }

  for (int i = 0; i < 16; i++) {
    for (int n = 0; n < 16; n++) {
      if ((buffer[i] >> n) & 0x01) {
        charpic[i*16+15-n]=color;
      }else{
				charpic[i*16+15-n]=backcolor;
			}
    }
  }
	
	writeCommand(ILI9341_CASET);
  spiWrite16(x);
  spiWrite16(x + 16 - 1);
  writeCommand(ILI9341_PASET);
  spiWrite16(y);
  spiWrite16(y + 16 - 1);
  writeCommand(ILI9341_RAMWR);
	
	HAL_SPI_Transmit(&hspi2,(uint8_t *)charpic,16*16*2,10);
}

void drawCircul(uint16_t x, uint16_t y, uint16_t r, uint16_t color) {
  uint16_t length = 0;
  uint16_t distenchtopoint = r;
  while (length < distenchtopoint) {
    length = (int)sqrt((double)(r * r - distenchtopoint * distenchtopoint));
    drawLine(x - length, y - distenchtopoint, x + length, y - distenchtopoint,
             color);
    drawLine(x - length, y + distenchtopoint, x + length, y + distenchtopoint,
             color);
    drawLine(x + distenchtopoint, y - length, x + distenchtopoint, y + length,
             color);
    drawLine(x - distenchtopoint, y - length, x - distenchtopoint, y + length,
             color);
    distenchtopoint--;
  }
  drawRectangle(x - distenchtopoint, y - distenchtopoint,
                2 * distenchtopoint + 1, 2 * distenchtopoint + 1, color);
}

void drawRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h,
                   uint16_t color) {
  writeCommand(ILI9341_CASET);
  spiWrite16(x);
  spiWrite16(x + w - 1);
  writeCommand(ILI9341_PASET);
  spiWrite16(y);
  spiWrite16(y + h - 1);
  writeCommand(ILI9341_RAMWR);
  int i;
	uint16_t bufferSize;
	if(w*h>256)
		bufferSize=512;
	else
		bufferSize=w*h*2;
  uint8_t data_16bit[bufferSize];
  for (i = 0; i < bufferSize; i += 2) {
    data_16bit[i + 0] = (color) >> 8;
    data_16bit[i + 1] = (color)&0x00ff;
  }

  HAL_SPI_Transmit(&hspi2, data_16bit, 2, 2);

  for (i = 0; w * h - i > bufferSize/2; i += bufferSize/2) {
    HAL_SPI_Transmit(&hspi2, data_16bit, bufferSize, 50);
  }

  HAL_SPI_Transmit(&hspi2, data_16bit, 2 * (w * h - i), 50);
}

void drawPoint(uint16_t x, uint16_t y, uint16_t color) {
  drawRectangle(x, y, 1, 1, color);
}

void drawLine(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2,
              uint16_t color) {
  if (x1 == x2) {
    drawRectangle(x1, y1, 1, y2 - y1 + 1, color);
  } else if (y1 == y2) {
    drawRectangle(x1, y1, x2 - x1 + 1, 1, color);
  } else if (x2 - x1 > 0 && y2 - y1 > 0) {
    uint16_t xnow = x1;
    uint16_t ynow = y1;
    while (xnow != x2 || ynow != y2) {
      drawPoint(xnow, ynow, color);
      if ((x2 - xnow) * (y2 - y1) >= (y2 - ynow) * (x2 - x1)) {
        xnow++;
      } else {
        ynow++;
      }
    }
  } else if (x2 - x1 < 0 && y2 - y1 < 0) {
    uint16_t temp;
    temp = x2;
    x2 = x1;
    x1 = temp;
    temp = y2;
    y2 = y1;
    y1 = temp;
    uint16_t xnow = x1;
    uint16_t ynow = y1;
    while (xnow != x2 || ynow != y2) {
      drawPoint(xnow, ynow, color);
      if ((x2 - xnow) * (y2 - y1) >= (y2 - ynow) * (x2 - x1)) {
        xnow++;
      } else {
        ynow++;
      }
    }
  } else if (x2 - x1 > 0 && y2 - y1 < 0) {
    uint16_t xnow = x1;
    uint16_t ynow = y1;
    while (xnow != x2 || ynow != y2) {
      drawPoint(xnow, ynow, color);
      if ((x2 - xnow) * (y2 - y1) <= (y2 - ynow) * (x2 - x1)) {
        xnow++;
      } else {
        ynow--;
      }
    }
  } else if (x2 - x1 < 0 && y2 - y1 > 0) {
    uint16_t xnow = x1;
    uint16_t ynow = y1;
    while (xnow != x2 || ynow != y2) {
      drawPoint(xnow, ynow, color);
      if ((x2 - xnow) * (y2 - y1) <= (y2 - ynow) * (x2 - x1)) {
        xnow--;
      } else {
        ynow++;
      }
    }
  }
}

void lcdInit() {
  srand(RAND_SEED);

  writeCommand(0xEF);
  spiWrite(0x03);
  spiWrite(0x80);
  spiWrite(0x02);

  writeCommand(0xCF);
  spiWrite(0x00);
  spiWrite(0XC1);
  spiWrite(0X30);

  writeCommand(0xED);
  spiWrite(0x64);
  spiWrite(0x03);
  spiWrite(0X12);
  spiWrite(0X81);

  writeCommand(0xE8);
  spiWrite(0x85);
  spiWrite(0x00);
  spiWrite(0x78);

  writeCommand(0xCB);
  spiWrite(0x39);
  spiWrite(0x2C);
  spiWrite(0x00);
  spiWrite(0x34);
  spiWrite(0x02);

  writeCommand(0xF7);
  spiWrite(0x20);

  writeCommand(0xEA);
  spiWrite(0x00);
  spiWrite(0x00);

  writeCommand(ILI9341_PWCTR1);  // Power control
  spiWrite(0x23);                // VRH[5:0]

  writeCommand(ILI9341_PWCTR2);  // Power control
  spiWrite(0x10);                // SAP[2:0];BT[3:0]

  writeCommand(ILI9341_VMCTR1);  // VCM control
  spiWrite(0x3e);
  spiWrite(0x28);

  writeCommand(ILI9341_VMCTR2);  // VCM control2
  spiWrite(0x86);                //--

  writeCommand(ILI9341_MADCTL);  // Memory Access Control
  spiWrite(0x48);

  writeCommand(ILI9341_VSCRSADD);  // Vertical scroll
  spiWrite(0x00);
  spiWrite(0x00);  // Zero

  writeCommand(ILI9341_PIXFMT);
  spiWrite(0x55);

  writeCommand(ILI9341_FRMCTR1);
  spiWrite(0x00);
  spiWrite(0x18);

  writeCommand(ILI9341_DFUNCTR);  // Display Function Control
  spiWrite(0x08);
  spiWrite(0x82);
  spiWrite(0x27);

  writeCommand(0xF2);  // 3Gamma Function Disable
  spiWrite(0x00);

  writeCommand(ILI9341_GAMMASET);  // Gamma curve selected
  spiWrite(0x01);

  writeCommand(ILI9341_GMCTRP1);  // Set Gamma
  spiWrite(0x0F);
  spiWrite(0x31);
  spiWrite(0x2B);
  spiWrite(0x0C);
  spiWrite(0x0E);
  spiWrite(0x08);
  spiWrite(0x4E);
  spiWrite(0xF1);
  spiWrite(0x37);
  spiWrite(0x07);
  spiWrite(0x10);
  spiWrite(0x03);
  spiWrite(0x0E);
  spiWrite(0x09);
  spiWrite(0x00);

  writeCommand(ILI9341_GMCTRN1);  // Set Gamma
  spiWrite(0x00);
  spiWrite(0x0E);
  spiWrite(0x14);
  spiWrite(0x03);
  spiWrite(0x11);
  spiWrite(0x07);
  spiWrite(0x31);
  spiWrite(0xC1);
  spiWrite(0x48);
  spiWrite(0x08);
  spiWrite(0x0F);
  spiWrite(0x0C);
  spiWrite(0x31);
  spiWrite(0x36);
  spiWrite(0x0F);

  writeCommand(ILI9341_SLPOUT);  // Exit Sleep
  HAL_Delay(120);
  writeCommand(ILI9341_DISPON);  // Display on
  HAL_Delay(120);
}

void writeCommand(uint8_t cmd) {
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);
  HAL_SPI_Transmit(&hspi2, &cmd, 1, 2);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);
}

void spiWrite(uint8_t data) { HAL_SPI_Transmit(&hspi2, &data, 1, 2); }

void spiWrite16(uint16_t data) {
  uint8_t bit8data[2] = {(data) >> 8, (data)&0x00ff};
  HAL_SPI_Transmit(&hspi2, bit8data, 2, 2);
}

void lcdRestart(void) {
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_SET);
  HAL_Delay(100);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_RESET);
  HAL_Delay(100);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_SET);
  HAL_Delay(200);
}

void drawPictu(uint16_t x, uint16_t y, const char *path) {
  FRESULT res;
  FIL file_obj;

  res = f_open(&file_obj, path, FA_OPEN_EXISTING | FA_READ);
  if (res != FR_OK) {
    return;
  }

  uint32_t br;
  BITMAP_HEADER fileHead;
  uint8_t headBuffer[54];

  res = f_read(&file_obj, headBuffer, 54, &br);
  if (res != FR_OK) {
    f_close(&file_obj);
    return;
  }

  fileHead.bfType = *(uint16_t *)(headBuffer);
  if (fileHead.bfType != 0x4d42) {
    f_close(&file_obj);
    return;
  }

  fileHead.bfSize = *(uint16_t *)(headBuffer + 2);
  fileHead.bfSize |= (*(uint16_t *)(headBuffer + 4)) << 16;

  fileHead.bfOffBits = *(uint16_t *)(headBuffer + 10);
  fileHead.bfOffBits |= (*(uint16_t *)(headBuffer + 12)) << 16;

  fileHead.biWidth = *(uint16_t *)(headBuffer + 18);
  fileHead.biWidth |= (*(uint16_t *)(headBuffer + 20)) << 16;

  fileHead.biHeight = *(uint16_t *)(headBuffer + 22);
  fileHead.biHeight |= (*(uint16_t *)(headBuffer + 24)) << 16;

  fileHead.biBitCount = *(uint16_t *)(headBuffer + 28);
  fileHead.biCompression = *(uint16_t *)(headBuffer + 30);
  fileHead.biCompression |= *(uint16_t *)(headBuffer + 32) << 16;

  const uint32_t MULTIPLE = 4;
  uint32_t originBiWidth = fileHead.biWidth;
  uint8_t rowRemain = fileHead.biWidth % MULTIPLE;
  if (rowRemain != 0) {
    uint32_t div = fileHead.biWidth / MULTIPLE;
    fileHead.biWidth = (div + 1) * MULTIPLE;
  }

  uint16_t lenToTop = fileHead.biHeight + y;
  uint16_t lenToLef = x;
  uint8_t Blue, Red, Green;
  switch (fileHead.biBitCount) {
    case 24: {
      const uint16_t BUFFER_SIZE = fileHead.biWidth * 3 * 12;
      uint8_t bmpBuffer[BUFFER_SIZE];
      while (1) {
        res = f_read(&file_obj, bmpBuffer, BUFFER_SIZE, &br);
        if (res != FR_OK) {
          f_close(&file_obj);
          return;
        }

        if (br == 0) {
          break;
        }
        for (int n = 0; n < br / (fileHead.biWidth * 3); n++) {
          writeCommand(ILI9341_CASET);
          spiWrite16(lenToLef);
          spiWrite16(lenToLef + originBiWidth - 1);
          writeCommand(ILI9341_PASET);
          spiWrite16(lenToTop);
          spiWrite16(lenToTop);
          writeCommand(ILI9341_RAMWR);
          uint16_t bmpColor[originBiWidth];
          for (int i = 0; i < originBiWidth * 3; i += 3) {
            Blue = bmpBuffer[n * fileHead.biWidth * 3 + i + 0];
            Green = bmpBuffer[n * fileHead.biWidth * 3 + i + 1];
            Red = bmpBuffer[n * fileHead.biWidth * 3 + i + 2];

            bmpColor[i / 3] = RGB(Red, Green, Blue);
            uint8_t temp = 0;
            temp = bmpColor[i / 3] >> 8;
            bmpColor[i / 3] = (bmpColor[i / 3] & 0xff) << 8 | temp;
          }
          HAL_SPI_Transmit(&hspi2, (uint8_t *)bmpColor, originBiWidth * 2, 20);
          lenToTop--;
        }
      }
      break;
    }
    case 32: {
      const uint16_t BUFFER_SIZE = fileHead.biWidth * 4;
      uint8_t bmpBuffer[BUFFER_SIZE];
      while (1) {
        res = f_read(&file_obj, bmpBuffer, BUFFER_SIZE, &br);
        if (res != FR_OK) {
          f_close(&file_obj);
          return;
        }

        if (br == 0) {
          break;
        }

        writeCommand(ILI9341_CASET);
        spiWrite16(lenToLef);
        spiWrite16(lenToLef + originBiWidth - 1);
        writeCommand(ILI9341_PASET);
        spiWrite16(lenToTop);
        spiWrite16(lenToTop);
        writeCommand(ILI9341_RAMWR);
        uint16_t bmpColor[originBiWidth];
        for (int i = 0; i < originBiWidth * 4; i += 4) {
          Blue = bmpBuffer[i + 0];
          Green = bmpBuffer[i + 1];
          Red = bmpBuffer[i + 2];

          bmpColor[i / 4] = RGB(Red, Green, Blue);

          uint8_t temp = 0;
          temp = bmpColor[i / 4] >> 8;
          bmpColor[i / 4] = (bmpColor[i / 4] & 0xff) << 8 | temp;
        }
        HAL_SPI_Transmit(&hspi2, (uint8_t *)bmpColor, originBiWidth * 2, 20);
        lenToTop--;
        break;
      }
    }
  }
  f_close(&file_obj);
}

uint16_t RGB(uint8_t r, uint8_t g, uint8_t b) {
  return ((((r >> 3) & 0x1f) << 11) | (((g >> 2) & 0x3f) << 5) |
          ((b >> 3) & 0x1f));
}

uint16_t getrRGB(void) {
  /*
  int red=rand()%31;
  int green=rand()%63;
  int blue=rand()%31;
  return (blue&0x1f)|((green&0x3f)<<5)|((blue&0x1f)<<(5+6));
  */
  return rand() % 0xffff;
}
